package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
)

type DemoJob struct {
	Queue      string      `json:"queue"`
	Payload    interface{} `json:"payload"`
	MaxRetries int         `json:"max_retries"`
	Priority   string      `json:"priority"`
}

func main() {
	log.Println("Starting Mini Asynq Demo...")

	// Set up signal handling for graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// Start demo job generation
	go generateDemoJobs()

	// Wait for shutdown signal
	<-sigChan
	log.Println("Shutting down demo...")
}

func generateDemoJobs() {
	// Sample job types
	jobTypes := []string{
		"email_notification",
		"data_processing",
		"report_generation",
		"image_resizing",
		"api_sync",
		"backup_task",
		"cleanup_task",
	}

	// Sample payloads
	payloads := map[string]interface{}{
		"email_notification": map[string]interface{}{
			"to":      "user@example.com",
			"subject": "Welcome to Mini Asynq!",
			"body":    "This is a test email generated by the demo system.",
		},
		"data_processing": map[string]interface{}{
			"file_id":   "data_12345",
			"operation": "transform",
			"format":    "csv_to_json",
		},
		"report_generation": map[string]interface{}{
			"report_type": "sales_summary",
			"date_range":  "last_30_days",
			"format":      "pdf",
		},
		"image_resizing": map[string]interface{}{
			"image_url": "https://example.com/images/sample.jpg",
			"sizes":     []int{100, 200, 400},
		},
		"api_sync": map[string]interface{}{
			"source": "external_api",
			"target": "internal_db",
			"since":  "2024-01-01",
		},
		"backup_task": map[string]interface{}{
			"database": "main_db",
			"storage":  "s3",
			"bucket":   "backups",
		},
		"cleanup_task": map[string]interface{}{
			"table":      "temp_data",
			"older_than": "7_days",
		},
	}

	// Queues and priorities
	queues := []string{"default", "high", "low"}
	priorities := []string{"normal", "high", "low"}

	// Generate jobs continuously
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Randomly select job type
			jobType := jobTypes[rand.Intn(len(jobTypes))]
			payload := payloads[jobType]

			// Randomly select queue and priority
			queue := queues[rand.Intn(len(queues))]
			priority := priorities[rand.Intn(len(priorities))]

			// Random retries (0-5)
			retries := rand.Intn(6)

			// Create job
			job := DemoJob{
				Queue:      queue,
				Payload:    payload,
				MaxRetries: retries,
				Priority:   priority,
			}

			// Send to API
			err := enqueueJob(job)
			if err != nil {
				log.Printf("Failed to enqueue job: %v", err)
			} else {
				log.Printf("Enqueued %s job to %s queue with %s priority", jobType, queue, priority)
			}
		}
	}
}

func enqueueJob(job DemoJob) error {
	// Convert job to JSON
	jsonData, err := json.Marshal(job)
	if err != nil {
		return fmt.Errorf("failed to marshal job: %w", err)
	}

	// Create HTTP request
	req, err := http.NewRequest("POST", "http://localhost:8080/api/v1/jobs", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")

	// Send request
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	return nil
}
